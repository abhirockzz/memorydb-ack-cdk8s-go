// subnetgroups_memorydbservicesk8saws
package subnetgroups_memorydbservicesk8saws

import (
	_init_ "example.com/memorydb-cdk8s/imports/subnetgroups_memorydbservicesk8saws/jsii"
	_jsii_ "github.com/aws/jsii-runtime-go/runtime"

	"example.com/memorydb-cdk8s/imports/subnetgroups_memorydbservicesk8saws/internal"
	"github.com/aws/constructs-go/constructs/v10"
	"github.com/cdk8s-team/cdk8s-core-go/cdk8s/v2"
)

// SubnetGroup is the Schema for the SubnetGroups API.
type SubnetGroup interface {
	cdk8s.ApiObject
	// The group portion of the API version (e.g. `authorization.k8s.io`).
	ApiGroup() *string
	// The object's API version (e.g. `authorization.k8s.io/v1`).
	ApiVersion() *string
	// The chart in which this object is defined.
	Chart() cdk8s.Chart
	// The object kind.
	Kind() *string
	// Metadata associated with this API object.
	Metadata() cdk8s.ApiObjectMetadataDefinition
	// The name of the API object.
	//
	// If a name is specified in `metadata.name` this will be the name returned.
	// Otherwise, a name will be generated by calling
	// `Chart.of(this).generatedObjectName(this)`, which by default uses the
	// construct path to generate a DNS-compatible name for the resource.
	Name() *string
	// The tree node.
	Node() constructs.Node
	// Create a dependency between this ApiObject and other constructs.
	//
	// These can be other ApiObjects, Charts, or custom.
	AddDependency(dependencies ...constructs.IConstruct)
	// Applies a set of RFC-6902 JSON-Patch operations to the manifest synthesized for this API object.
	//
	// Example:
	//     kubePod.addJsonPatch(JsonPatch.replace('/spec/enableServiceLinks', true));
	//
	AddJsonPatch(ops ...cdk8s.JsonPatch)
	// Renders the object to Kubernetes JSON.
	ToJson() interface{}
	// Returns a string representation of this construct.
	ToString() *string
}

// The jsii proxy struct for SubnetGroup
type jsiiProxy_SubnetGroup struct {
	internal.Type__cdk8sApiObject
}

func (j *jsiiProxy_SubnetGroup) ApiGroup() *string {
	var returns *string
	_jsii_.Get(
		j,
		"apiGroup",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_SubnetGroup) ApiVersion() *string {
	var returns *string
	_jsii_.Get(
		j,
		"apiVersion",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_SubnetGroup) Chart() cdk8s.Chart {
	var returns cdk8s.Chart
	_jsii_.Get(
		j,
		"chart",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_SubnetGroup) Kind() *string {
	var returns *string
	_jsii_.Get(
		j,
		"kind",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_SubnetGroup) Metadata() cdk8s.ApiObjectMetadataDefinition {
	var returns cdk8s.ApiObjectMetadataDefinition
	_jsii_.Get(
		j,
		"metadata",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_SubnetGroup) Name() *string {
	var returns *string
	_jsii_.Get(
		j,
		"name",
		&returns,
	)
	return returns
}

func (j *jsiiProxy_SubnetGroup) Node() constructs.Node {
	var returns constructs.Node
	_jsii_.Get(
		j,
		"node",
		&returns,
	)
	return returns
}


// Defines a "SubnetGroup" API object.
func NewSubnetGroup(scope constructs.Construct, id *string, props *SubnetGroupProps) SubnetGroup {
	_init_.Initialize()

	j := jsiiProxy_SubnetGroup{}

	_jsii_.Create(
		"subnetgroups_memorydbservicesk8saws.SubnetGroup",
		[]interface{}{scope, id, props},
		&j,
	)

	return &j
}

// Defines a "SubnetGroup" API object.
func NewSubnetGroup_Override(s SubnetGroup, scope constructs.Construct, id *string, props *SubnetGroupProps) {
	_init_.Initialize()

	_jsii_.Create(
		"subnetgroups_memorydbservicesk8saws.SubnetGroup",
		[]interface{}{scope, id, props},
		s,
	)
}

// Checks if `x` is a construct.
//
// Use this method instead of `instanceof` to properly detect `Construct`
// instances, even when the construct library is symlinked.
//
// Explanation: in JavaScript, multiple copies of the `constructs` library on
// disk are seen as independent, completely different libraries. As a
// consequence, the class `Construct` in each copy of the `constructs` library
// is seen as a different class, and an instance of one class will not test as
// `instanceof` the other class. `npm install` will not create installations
// like this, but users may manually symlink construct libraries together or
// use a monorepo tool: in those cases, multiple copies of the `constructs`
// library can be accidentally installed, and `instanceof` will behave
// unpredictably. It is safest to avoid using `instanceof`, and using
// this type-testing method instead.
//
// Returns: true if `x` is an object created from a class which extends `Construct`.
func SubnetGroup_IsConstruct(x interface{}) *bool {
	_init_.Initialize()

	var returns *bool

	_jsii_.StaticInvoke(
		"subnetgroups_memorydbservicesk8saws.SubnetGroup",
		"isConstruct",
		[]interface{}{x},
		&returns,
	)

	return returns
}

// Renders a Kubernetes manifest for "SubnetGroup".
//
// This can be used to inline resource manifests inside other objects (e.g. as templates).
func SubnetGroup_Manifest(props *SubnetGroupProps) interface{} {
	_init_.Initialize()

	var returns interface{}

	_jsii_.StaticInvoke(
		"subnetgroups_memorydbservicesk8saws.SubnetGroup",
		"manifest",
		[]interface{}{props},
		&returns,
	)

	return returns
}

// Returns the `ApiObject` named `Resource` which is a child of the given construct.
//
// If `c` is an `ApiObject`, it is returned directly. Throws an
// exception if the construct does not have a child named `Default` _or_ if
// this child is not an `ApiObject`.
func SubnetGroup_Of(c constructs.IConstruct) cdk8s.ApiObject {
	_init_.Initialize()

	var returns cdk8s.ApiObject

	_jsii_.StaticInvoke(
		"subnetgroups_memorydbservicesk8saws.SubnetGroup",
		"of",
		[]interface{}{c},
		&returns,
	)

	return returns
}

func SubnetGroup_GVK() *cdk8s.GroupVersionKind {
	_init_.Initialize()
	var returns *cdk8s.GroupVersionKind
	_jsii_.StaticGet(
		"subnetgroups_memorydbservicesk8saws.SubnetGroup",
		"GVK",
		&returns,
	)
	return returns
}

func (s *jsiiProxy_SubnetGroup) AddDependency(dependencies ...constructs.IConstruct) {
	args := []interface{}{}
	for _, a := range dependencies {
		args = append(args, a)
	}

	_jsii_.InvokeVoid(
		s,
		"addDependency",
		args,
	)
}

func (s *jsiiProxy_SubnetGroup) AddJsonPatch(ops ...cdk8s.JsonPatch) {
	args := []interface{}{}
	for _, a := range ops {
		args = append(args, a)
	}

	_jsii_.InvokeVoid(
		s,
		"addJsonPatch",
		args,
	)
}

func (s *jsiiProxy_SubnetGroup) ToJson() interface{} {
	var returns interface{}

	_jsii_.Invoke(
		s,
		"toJson",
		nil, // no parameters
		&returns,
	)

	return returns
}

func (s *jsiiProxy_SubnetGroup) ToString() *string {
	var returns *string

	_jsii_.Invoke(
		s,
		"toString",
		nil, // no parameters
		&returns,
	)

	return returns
}

// SubnetGroup is the Schema for the SubnetGroups API.
type SubnetGroupProps struct {
	Metadata *cdk8s.ApiObjectMetadata `field:"optional" json:"metadata" yaml:"metadata"`
	// SubnetGroupSpec defines the desired state of SubnetGroup.
	//
	// Represents the output of one of the following operations:
	// * CreateSubnetGroup
	// * UpdateSubnetGroup
	// A subnet group is a collection of subnets (typically private) that you can designate for your clusters running in an Amazon Virtual Private Cloud (VPC) environment.
	Spec *SubnetGroupSpec `field:"optional" json:"spec" yaml:"spec"`
}

// SubnetGroupSpec defines the desired state of SubnetGroup.
//
// Represents the output of one of the following operations:
// * CreateSubnetGroup
// * UpdateSubnetGroup
// A subnet group is a collection of subnets (typically private) that you can designate for your clusters running in an Amazon Virtual Private Cloud (VPC) environment.
type SubnetGroupSpec struct {
	// The name of the subnet group.
	Name *string `field:"required" json:"name" yaml:"name"`
	// A list of VPC subnet IDs for the subnet group.
	SubnetIDs *[]*string `field:"required" json:"subnetIDs" yaml:"subnetIDs"`
	// A description for the subnet group.
	Description *string `field:"optional" json:"description" yaml:"description"`
	// A list of tags to be added to this resource.
	//
	// A tag is a key-value pair. A tag key must be accompanied by a tag value, although null is accepted.
	Tags *[]*SubnetGroupSpecTags `field:"optional" json:"tags" yaml:"tags"`
}

// A tag that can be added to an MemoryDB resource.
//
// Tags are composed of a Key/Value pair. You can use tags to categorize and track all your MemoryDB resources. When you add or remove tags on clusters, those actions will be replicated to all nodes in the cluster. A tag with a null Value is permitted. For more information, see Tagging your MemoryDB resources (https://docs.aws.amazon.com/MemoryDB/latest/devguide/tagging-resources.html)
type SubnetGroupSpecTags struct {
	Key *string `field:"optional" json:"key" yaml:"key"`
	Value *string `field:"optional" json:"value" yaml:"value"`
}

